#!/usr/bin/env node
/**
 * Coverage Gap Resolver
 *
 * Reads coverage-gaps.json and auto-generates skeleton curated config files
 * for actionable gaps with high or medium confidence. Low-confidence and
 * informational gaps are logged but not acted upon.
 *
 * The generated configs have autoGenerated: true so the pipeline knows
 * they were machine-created and may need human review.
 */

import fs from "fs";
import path from "path";
import { readJsonIfExists, writeJsonPretty, rootDataPath } from "./lib/helpers.js";

const dataDir = rootDataPath();
const defaultConfigDir = path.resolve(process.cwd(), "scripts", "config");

/**
 * Derive a human-readable name from a gap's matched pattern and sport.
 * E.g. "champions league" + "football" → "Champions League Football 2026"
 */
function deriveName(gap) {
	const words = gap.matchedPattern
		.split(/\s*\|\s*/)
		.filter(Boolean);

	// Pick the first (most specific) pattern fragment as the name base
	const base = words[0] || gap.id;
	const capitalised = base
		.replace(/[^a-zA-Z0-9\s]/g, "")
		.trim()
		.split(/\s+/)
		.map((w) => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
		.join(" ");

	const year = new Date().getFullYear();
	return `${capitalised} ${year}`;
}

/**
 * Format a date as YYYY-MM-DD.
 */
function formatDate(date) {
	return date.toISOString().split("T")[0];
}

/**
 * Check whether a config already exists that covers a given sport + type
 * combination. Looks at existing JSON files in the config directory.
 */
function configAlreadyExists(gap, configDir) {
	if (!fs.existsSync(configDir)) return false;

	const files = fs.readdirSync(configDir).filter((f) => f.endsWith(".json"));
	for (const file of files) {
		const config = readJsonIfExists(path.join(configDir, file));
		if (!config) continue;

		// Match by context containing the gap id
		if (config.context && config.context === gap.id) return true;

		// Match by sport prefix in filename + type keyword in filename
		const lower = file.toLowerCase();
		if (lower.startsWith(gap.sport) && lower.includes(gap.type)) return true;
	}
	return false;
}

/**
 * Build a skeleton config object from a coverage gap.
 */
function buildSkeletonConfig(gap) {
	const now = new Date();
	const endDate = new Date(now.getTime() + 90 * 24 * 60 * 60 * 1000);

	return {
		name: deriveName(gap),
		sport: gap.sport,
		location: "TBD",
		startDate: formatDate(now),
		endDate: formatDate(endDate),
		context: gap.id,
		autoGenerated: true,
		generatedFrom: "coverage-gap",
		headlines: gap.headlines.slice(),
		events: [],
	};
}

/**
 * Resolve actionable coverage gaps by generating skeleton config files.
 *
 * @param {object}  options
 * @param {string}  [options.configDir]       - Directory for config output
 * @param {string}  [options.coverageGapPath] - Path to coverage-gaps.json
 * @returns {{ created: string[], skipped: string[], logged: string[] }}
 */
export function resolveCoverageGaps({ configDir, coverageGapPath } = {}) {
	const cfgDir = configDir || defaultConfigDir;
	const gapPath = coverageGapPath || path.join(dataDir, "coverage-gaps.json");

	const data = readJsonIfExists(gapPath);
	if (!data || !Array.isArray(data.gaps)) {
		console.log("No coverage-gaps.json found or no gaps array — nothing to resolve.");
		return { created: [], skipped: [], logged: [] };
	}

	const created = [];
	const skipped = [];
	const logged = [];

	for (const gap of data.gaps) {
		// Only act on actionable gaps
		if (gap.classification !== "actionable") {
			logged.push(`[${gap.confidence}] ${gap.sport}/${gap.type}: informational — skipped`);
			continue;
		}

		// Only act on high or medium confidence
		if (gap.confidence === "low") {
			logged.push(`[low] ${gap.sport}/${gap.type}: ${gap.matchedPattern} — low confidence, skipped`);
			continue;
		}

		// Check for existing config
		if (configAlreadyExists(gap, cfgDir)) {
			skipped.push(`${gap.sport}/${gap.type}: config already exists`);
			continue;
		}

		// Create skeleton config
		const config = buildSkeletonConfig(gap);
		const filename = gap.suggestedConfigName || `${gap.sport}-${gap.type}-${new Date().getFullYear()}.json`;
		const outPath = path.join(cfgDir, filename);

		// Ensure config directory exists
		if (!fs.existsSync(cfgDir)) {
			fs.mkdirSync(cfgDir, { recursive: true });
		}

		writeJsonPretty(outPath, config);
		created.push(filename);
		console.log(`  Created: ${filename} (${gap.sport}/${gap.type}, confidence: ${gap.confidence})`);
	}

	// Log summary
	for (const msg of logged) {
		console.log(`  Logged: ${msg}`);
	}
	for (const msg of skipped) {
		console.log(`  Skipped: ${msg}`);
	}

	console.log(`\nResolved coverage gaps: ${created.length} created, ${skipped.length} skipped, ${logged.length} logged`);

	return { created, skipped, logged };
}

async function main() {
	resolveCoverageGaps();
}

if (process.argv[1]?.includes("resolve-coverage-gaps")) {
	main().catch((err) => {
		console.error("Coverage gap resolution failed:", err);
		process.exit(1);
	});
}
