#!/usr/bin/env node
/**
 * Discover Events — LLM-Powered Discovery Agent
 *
 * Uses Claude CLI with WebSearch to research and populate curated event configs.
 *
 * Trigger conditions (any of):
 * - A config has needsResearch: true
 * - A coverage gap with confidence >= "medium" has no matching config
 * - A config has norwegianAthletes array that hasn't been refreshed in 7+ days
 *
 * Safeguards:
 * - Max 3 discovery tasks per run
 * - Requires CLAUDE_CODE_OAUTH_TOKEN (discovery needs web search)
 * - Validates returned JSON against schema before writing
 * - Keeps autoGenerated: true on all machine-written configs
 * - Adds lastResearched timestamp to track freshness
 */

import fs from "fs";
import path from "path";
import { execSync } from "child_process";
import { readJsonIfExists, writeJsonPretty, rootDataPath, iso, MS_PER_DAY, parseCliJsonOutput } from "./lib/helpers.js";
import { buildVerificationHints } from "./lib/schedule-verifier.js";
import { factCheck, buildFactCheckHints, appendFactCheckHistory } from "./lib/fact-checker.js";
import { LLMClient } from "./lib/llm-client.js";

const MAX_TASKS_PER_RUN = 3;
const ATHLETE_REFRESH_DAYS = 7;
const EVENT_WINDOW_DAYS = 14;

const defaultConfigDir = path.resolve(process.cwd(), "scripts", "config");

/**
 * Find configs and gaps that need research.
 * Returns a prioritized task list (max MAX_TASKS_PER_RUN).
 */
export function findResearchTasks(configs, coverageGaps, now = new Date()) {
	const tasks = [];

	// Priority 1: configs with needsResearch flag
	for (const { filename, config } of configs) {
		if (config.needsResearch === true) {
			tasks.push({
				type: "new-config",
				priority: 1,
				filename,
				config,
				reason: "needsResearch flag set",
			});
		}
	}

	// Priority 2: autoGenerated configs with empty events (but no needsResearch yet)
	for (const { filename, config } of configs) {
		if (
			config.autoGenerated === true &&
			(!Array.isArray(config.events) || config.events.length === 0) &&
			!config.needsResearch
		) {
			tasks.push({
				type: "new-config",
				priority: 2,
				filename,
				config,
				reason: "autoGenerated with empty events",
			});
		}
	}

	// Priority 3: stale norwegianAthletes (haven't been refreshed in 7+ days)
	for (const { filename, config } of configs) {
		if (
			Array.isArray(config.norwegianAthletes) &&
			config.norwegianAthletes.length > 0
		) {
			const lastResearched = config.lastResearched
				? new Date(config.lastResearched)
				: null;
			const staleMs = ATHLETE_REFRESH_DAYS * MS_PER_DAY;
			if (!lastResearched || now.getTime() - lastResearched.getTime() > staleMs) {
				// Don't duplicate if already queued
				if (!tasks.some((t) => t.filename === filename)) {
					tasks.push({
						type: "refresh-athletes",
						priority: 3,
						filename,
						config,
						reason: lastResearched
							? `Athletes last refreshed ${lastResearched.toISOString().split("T")[0]}`
							: "Athletes never refreshed",
					});
				}
			}
		}
	}

	// Priority 4: coverage gaps with medium+ confidence that have no matching config
	if (coverageGaps?.gaps) {
		const configNames = new Set(configs.map((c) => c.config.context || c.config.name?.toLowerCase()));
		for (const gap of coverageGaps.gaps) {
			if (gap.confidence === "low") continue;
			if (gap.classification !== "actionable") continue;
			const gapId = gap.id || gap.matchedPattern;
			if (configNames.has(gapId)) continue;
			tasks.push({
				type: "coverage-gap",
				priority: 4,
				gap,
				reason: `Coverage gap: ${gap.matchedPattern} (${gap.confidence})`,
			});
		}
	}

	// Sort by priority and take top N
	tasks.sort((a, b) => a.priority - b.priority);
	return tasks.slice(0, MAX_TASKS_PER_RUN);
}

/**
 * Build a research prompt for a discovery task.
 * @param {object} task - Discovery task
 * @param {object} userContext - User preferences
 * @param {string[]} verificationHints - Optional accuracy correction hints from verification history
 */
export function buildResearchPrompt(task, userContext, verificationHints) {
	const now = new Date();
	const windowEnd = new Date(now.getTime() + EVENT_WINDOW_DAYS * MS_PER_DAY);
	const windowStr = `${now.toISOString().split("T")[0]} to ${windowEnd.toISOString().split("T")[0]}`;

	if (task.type === "refresh-athletes") {
		return `You are a sports research assistant. Your job is to verify and update athlete rosters.

TASK: Refresh Norwegian athletes for "${task.config.name}" (${task.config.sport || "unknown sport"})
CURRENT ATHLETES: ${JSON.stringify(task.config.norwegianAthletes)}

INSTRUCTIONS:
1. Search for current Norwegian athletes competing in this event
2. Check for retirements, nationality changes, or new qualifiers
3. Return ONLY valid JSON matching this schema:
{
  "norwegianAthletes": ["Name 1", "Name 2"],
  "changes": ["Added X (new qualifier)", "Removed Y (retired)"]
}
4. If no changes needed, return the same list with empty changes array
5. Only include athletes who are currently active and Norwegian

Return ONLY the JSON object, no markdown fences.`;
	}

	const configJson = task.config
		? JSON.stringify(task.config, null, 2)
		: JSON.stringify(task.gap || {}, null, 2);

	const sportHint = task.config?.sport || task.gap?.sport || "unknown";
	const nameHint = task.config?.name || task.gap?.matchedPattern || "Unknown Event";

	const userInterests = userContext
		? `\nUSER INTERESTS: ${JSON.stringify(userContext)}`
		: "";

	const accuracySection = Array.isArray(verificationHints) && verificationHints.length > 0
		? `\n\nACCURACY CORRECTIONS:\n${verificationHints.join("\n")}`
		: "";

	return `You are a sports research assistant. Your job is to find accurate, current schedule data.

TASK: Research "${nameHint}" (${sportHint})
EXISTING CONFIG: ${configJson}${userInterests}

INSTRUCTIONS:
1. Search for the official schedule of this event
2. Find all Norwegian athletes/teams competing
3. Return ONLY valid JSON matching this schema:
{
  "events": [
    {
      "title": "Event name",
      "time": "2026-06-15T21:00:00+02:00",
      "venue": "Venue name",
      "norwegian": true,
      "norwegianPlayers": [{"name": "Player Name"}],
      "streaming": [{"platform": "NRK", "type": "tv"}]
    }
  ],
  "norwegianAthletes": ["Name 1", "Name 2"],
  "location": "City, Country",
  "startDate": "2026-06-10",
  "endDate": "2026-06-20"
}
4. Use ISO 8601 times with timezone offset (e.g., 2026-06-15T21:00:00+02:00)
5. Only include events in the window ${windowStr} (skip far-future events)
6. For athletes, verify current nationality and retirement status
7. For streaming, check if NRK, TV2, Eurosport, or Viaplay broadcast this event in Norway

Return ONLY the JSON object, no markdown fences.${accuracySection}`;
}

/**
 * Parse and validate a discovery result from Claude CLI.
 */
export function parseDiscoveryResult(raw) {
	let parsed;
	try {
		parsed = JSON.parse(raw);
	} catch {
		// Try extracting from markdown fences
		const match = raw.match(/```(?:json)?\s*([\s\S]*?)```/);
		if (match) {
			parsed = JSON.parse(match[1].trim());
		} else {
			throw new Error(`Could not parse JSON from discovery result`);
		}
	}

	// Validate events array if present
	if (parsed.events) {
		if (!Array.isArray(parsed.events)) {
			throw new Error("events must be an array");
		}
		for (const event of parsed.events) {
			if (!event.title || typeof event.title !== "string") {
				throw new Error("Each event must have a title string");
			}
			if (!event.time || typeof event.time !== "string") {
				throw new Error("Each event must have a time string");
			}
			// Validate time is parseable
			if (isNaN(new Date(event.time).getTime())) {
				throw new Error(`Invalid time: ${event.time}`);
			}
		}
	}

	// Validate norwegianAthletes if present
	if (parsed.norwegianAthletes && !Array.isArray(parsed.norwegianAthletes)) {
		throw new Error("norwegianAthletes must be an array");
	}

	return parsed;
}

/**
 * Sync per-event norwegianPlayers with the top-level roster.
 * Removes players from events who are no longer in the roster.
 */
export function syncEventPlayers(config) {
	if (!Array.isArray(config.norwegianAthletes) || !Array.isArray(config.events)) return;
	const roster = new Set(config.norwegianAthletes.map((n) => n.toLowerCase()));
	for (const event of config.events) {
		if (!Array.isArray(event.norwegianPlayers)) continue;
		event.norwegianPlayers = event.norwegianPlayers.filter(
			(p) => roster.has(p.name.toLowerCase())
		);
		if (event.norwegianPlayers.length === 0 && event.norwegian === true) {
			event.norwegian = false;
		}
	}
}

/**
 * Apply discovery results to a config, preserving autoGenerated flag.
 */
export function applyDiscovery(config, result, now = new Date()) {
	const updated = { ...config };

	if (Array.isArray(result.events) && result.events.length > 0) {
		updated.events = result.events;
		updated.needsResearch = false;
	}

	if (Array.isArray(result.norwegianAthletes) && result.norwegianAthletes.length > 0) {
		updated.norwegianAthletes = result.norwegianAthletes;
	}

	if (result.location && result.location !== "TBD") {
		updated.location = result.location;
	}

	if (result.startDate) {
		updated.startDate = result.startDate;
	}

	if (result.endDate) {
		updated.endDate = result.endDate;
	}

	updated.lastResearched = iso(now);
	updated.autoGenerated = true;

	return updated;
}

/**
 * Invoke Claude CLI with a prompt for web-search-enabled discovery.
 */
async function discoverWithClaudeCLI(prompt) {
	const dataDir = rootDataPath();
	const tmpFile = path.join(dataDir, ".discovery-prompt.tmp");
	fs.writeFileSync(tmpFile, prompt);
	try {
		const cmd = `cat "${tmpFile}" | npx -y @anthropic-ai/claude-code@latest -p --output-format json --max-turns 8 --allowedTools "WebSearch" "WebFetch"`;
		const output = execSync(cmd, {
			encoding: "utf-8",
			timeout: 180000,
			maxBuffer: 2 * 1024 * 1024,
		});
		const parsed = parseCliJsonOutput(output);
		return { content: parsed.result, usage: { ...parsed.usage, tracked: true, estimated: false } };
	} finally {
		try { fs.unlinkSync(tmpFile); } catch {}
	}
}

/**
 * Load all event configs from the config directory.
 */
function loadConfigs(configDir) {
	if (!fs.existsSync(configDir)) return [];
	const configs = [];
	for (const file of fs.readdirSync(configDir).filter((f) => f.endsWith(".json"))) {
		if (file === "user-context.json") continue;
		const config = readJsonIfExists(path.join(configDir, file));
		if (!config || Array.isArray(config)) continue; // Skip roster files
		if (typeof config.name !== "string") continue;
		configs.push({ filename: file, config });
	}
	return configs;
}

/**
 * Main discovery orchestrator.
 */
export async function runDiscovery({ configDir, dataDir, now } = {}) {
	const cfgDir = configDir || defaultConfigDir;
	const dDir = dataDir || rootDataPath();
	const timestamp = now || new Date();

	const log = { timestamp: iso(timestamp), tasks: [], skipped: null, tokenUsage: null };

	// Check for Claude CLI token
	if (!process.env.CLAUDE_CODE_OAUTH_TOKEN) {
		console.log("No CLAUDE_CODE_OAUTH_TOKEN — skipping discovery (requires web search).");
		log.skipped = "No CLAUDE_CODE_OAUTH_TOKEN";
		return log;
	}

	const configs = loadConfigs(cfgDir);
	const coverageGaps = readJsonIfExists(path.join(dDir, "coverage-gaps.json"));
	const userContext = readJsonIfExists(path.join(cfgDir, "user-context.json"));

	// Load verification history for accuracy hints
	const verificationHistory = readJsonIfExists(path.join(dDir, "verification-history.json"));
	const { hints: verificationHints } = buildVerificationHints(verificationHistory);
	if (verificationHints.length > 0) {
		console.log(`Injecting ${verificationHints.length} accuracy correction(s) from verification history`);
	}

	// Load fact-check history for accuracy hints
	const factCheckHistoryPath = path.join(dDir, "fact-check-history.json");
	const factCheckHistoryData = readJsonIfExists(factCheckHistoryPath) || [];
	const { hints: fcHints } = buildFactCheckHints(factCheckHistoryData);
	const allVerificationHints = [...verificationHints, ...fcHints];
	if (fcHints.length > 0) {
		console.log(`Injecting ${fcHints.length} fact-check hint(s) from history`);
	}

	// Load reference data for fact-checking discovered configs
	const allEvents = readJsonIfExists(path.join(dDir, "events.json")) || [];
	const standings = readJsonIfExists(path.join(dDir, "standings.json"));
	const rssDigest = readJsonIfExists(path.join(dDir, "rss-digest.json"));
	const factCheckLlm = new LLMClient();

	const tasks = findResearchTasks(configs, coverageGaps, timestamp);

	if (tasks.length === 0) {
		console.log("No discovery tasks needed — all configs are up to date.");
		log.skipped = "No tasks needed";
		return log;
	}

	console.log(`Found ${tasks.length} discovery task(s):`);

	let totalInput = 0;
	let totalOutput = 0;
	let totalCostUSD = 0;
	let totalCalls = 0;

	for (const task of tasks) {
		const taskLog = {
			type: task.type,
			target: task.filename || task.gap?.matchedPattern || "unknown",
			reason: task.reason,
			outcome: "pending",
		};
		log.tasks.push(taskLog);

		console.log(`\n  Researching: ${taskLog.target} (${task.reason})`);

		try {
			const prompt = buildResearchPrompt(task, userContext, allVerificationHints);
			totalCalls++;
			const cliResult = await discoverWithClaudeCLI(prompt);
			totalInput += cliResult.usage.input;
			totalOutput += cliResult.usage.output;
			totalCostUSD += cliResult.usage.costUSD || 0;
			const result = parseDiscoveryResult(cliResult.content);

			if (task.type === "refresh-athletes") {
				// Apply athlete refresh to existing config
				const configPath = path.join(cfgDir, task.filename);
				const currentConfig = readJsonIfExists(configPath);
				if (currentConfig && result.norwegianAthletes) {
					currentConfig.norwegianAthletes = result.norwegianAthletes;
					currentConfig.lastResearched = iso(timestamp);
					syncEventPlayers(currentConfig);
					writeJsonPretty(configPath, currentConfig);
					taskLog.outcome = "success";
					taskLog.changes = result.changes || [];
					console.log(`  Updated athletes in ${task.filename}`);
				}
			} else if (task.type === "new-config" && task.filename) {
				// Apply discovery to existing skeleton config
				const configPath = path.join(cfgDir, task.filename);
				const updated = applyDiscovery(task.config, result, timestamp);
				writeJsonPretty(configPath, updated);
				taskLog.outcome = "success";
				taskLog.eventsFound = result.events?.length || 0;
				console.log(`  Populated ${task.filename} with ${taskLog.eventsFound} events`);
			} else if (task.type === "coverage-gap") {
				// Create new config from coverage gap research
				const gap = task.gap;
				const filename = gap.suggestedConfigName || `${gap.sport}-${gap.type}-${new Date().getFullYear()}.json`;
				const newConfig = applyDiscovery(
					{
						name: result.name || gap.matchedPattern || filename.replace(".json", ""),
						sport: gap.sport,
						context: gap.id,
						autoGenerated: true,
						generatedFrom: "discovery",
						events: [],
					},
					result,
					timestamp,
				);
				const configPath = path.join(cfgDir, filename);
				writeJsonPretty(configPath, newConfig);
				taskLog.outcome = "success";
				taskLog.filename = filename;
				taskLog.eventsFound = result.events?.length || 0;
				console.log(`  Created ${filename} with ${taskLog.eventsFound} events`);
			}
			// Fact-check discovered events (best-effort)
			if (Array.isArray(result.events) && result.events.length > 0 && factCheckLlm.isAvailable()) {
				try {
					const factResult = await factCheck({
						items: result.events,
						itemType: "config-events",
						context: { events: allEvents, standings, rssDigest },
						llm: factCheckLlm,
					});
					if (factResult.issuesFound > 0) {
						console.log(`  Fact-check: ${factResult.issuesFound} issue(s) in ${taskLog.target}`);
						for (const f of factResult.findings) console.log(`    ${f.severity}: ${f.message}`);
					}
					taskLog.factCheck = { issues: factResult.issuesFound, findings: factResult.findings };
					appendFactCheckHistory(factCheckHistoryPath, {
						...factResult,
						itemType: "config-events",
					});
				} catch (fcErr) {
					console.warn(`  Fact-check failed (non-blocking): ${fcErr.message}`);
				}
			}
		} catch (err) {
			taskLog.outcome = "failed";
			taskLog.error = err.message;
			console.error(`  Failed: ${err.message}`);
		}
	}

	const succeeded = log.tasks.filter((t) => t.outcome === "success").length;
	const failed = log.tasks.filter((t) => t.outcome === "failed").length;

	log.tokenUsage = {
		input: totalInput,
		output: totalOutput,
		calls: totalCalls,
		total: totalInput + totalOutput,
		costUSD: totalCostUSD,
		tracked: true,
		estimated: false,
	};

	// Write discovery token usage to ai-quality.json
	const qualityPath = path.join(dDir, "ai-quality.json");
	const existingQuality = readJsonIfExists(qualityPath) || {};
	writeJsonPretty(qualityPath, {
		...existingQuality,
		discovery: {
			...existingQuality.discovery,
			tokenUsage: log.tokenUsage,
			lastRun: iso(timestamp),
			tasksExecuted: totalCalls,
			succeeded,
			failed,
		},
	});

	console.log(`\nDiscovery complete: ${succeeded} succeeded, ${failed} failed`);

	return log;
}

/**
 * Update dynamic athletes in user-context.json if configured.
 */
async function refreshDynamicAthletes(configDir, userContext) {
	if (!userContext?.dynamicAthletes) return;
	if (!process.env.CLAUDE_CODE_OAUTH_TOKEN) return;

	for (const [sport, settings] of Object.entries(userContext.dynamicAthletes)) {
		if (!settings.norwegian) continue;
		const refreshDays = settings.refreshDays || 14;
		const lastRefresh = settings.lastRefreshed ? new Date(settings.lastRefreshed) : null;
		if (lastRefresh && Date.now() - lastRefresh.getTime() < refreshDays * MS_PER_DAY) {
			continue;
		}

		console.log(`Refreshing dynamic Norwegian athletes for ${sport}...`);
		try {
			const prompt = `You are a sports research assistant. Search for the top current Norwegian ${sport} players/athletes.

Return ONLY valid JSON: { "athletes": ["Name 1", "Name 2", ...] }
Include only currently active, professional Norwegian athletes. Max 10.
No markdown fences.`;
			const cliResult = await discoverWithClaudeCLI(prompt);
			const result = parseDiscoveryResult(cliResult.content);
			if (Array.isArray(result.athletes) && result.athletes.length > 0) {
				// Update favoritePlayers with discovered athletes
				const existing = new Set(userContext.favoritePlayers || []);
				for (const athlete of result.athletes) {
					existing.add(athlete);
				}
				userContext.favoritePlayers = [...existing];
				userContext.dynamicAthletes[sport].lastRefreshed = iso();
				writeJsonPretty(path.join(configDir, "user-context.json"), userContext);
				console.log(`  Added ${result.athletes.length} ${sport} athletes`);
			}
		} catch (err) {
			console.error(`  Failed to refresh ${sport} athletes:`, err.message);
		}
	}
}

/**
 * Write discovery log to data directory.
 */
function writeDiscoveryLog(log, dataDir) {
	const logPath = path.join(dataDir, "discovery-log.json");
	const existing = readJsonIfExists(logPath) || { runs: [] };
	existing.runs.push(log);
	// Keep last 50 runs
	while (existing.runs.length > 50) existing.runs.shift();
	writeJsonPretty(logPath, existing);
}

async function main() {
	console.log("Running event discovery...");
	const cfgDir = defaultConfigDir;
	const dDir = rootDataPath();

	const log = await runDiscovery({ configDir: cfgDir, dataDir: dDir });
	writeDiscoveryLog(log, dDir);

	// Also refresh dynamic athletes if configured
	const userContext = readJsonIfExists(path.join(cfgDir, "user-context.json"));
	if (userContext) {
		await refreshDynamicAthletes(cfgDir, userContext);
	}
}

if (process.argv[1]?.includes("discover-events")) {
	main().catch((err) => {
		console.error("Event discovery failed:", err);
		process.exit(1);
	});
}
