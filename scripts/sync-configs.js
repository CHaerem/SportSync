#!/usr/bin/env node
/**
 * Sync Configs — Deterministic Config Maintenance
 *
 * Runs every pipeline cycle (2h). No LLM needed.
 *
 * Responsibilities:
 * 1. Prune past events — Remove events with time before now - 6h
 * 2. Archive expired configs — Move configs where endDate < today to archive/
 * 3. Flag needsResearch — Mark autoGenerated configs with empty events
 * 4. Log actions — Write docs/data/config-sync-log.json
 */

import fs from "fs";
import path from "path";
import { readJsonIfExists, writeJsonPretty, rootDataPath, iso, MS_PER_HOUR } from "./lib/helpers.js";
import { syncEventPlayers } from "./discover-events.js";

const defaultConfigDir = path.resolve(process.cwd(), "scripts", "config");
const defaultArchiveDir = path.resolve(process.cwd(), "scripts", "config", "archive");

/**
 * Remove events with time before now - 6h from a config.
 * Returns the number of events pruned.
 */
export function pruneExpiredEvents(config, now = new Date()) {
	if (!Array.isArray(config.events)) return 0;
	const cutoff = new Date(now.getTime() - 6 * MS_PER_HOUR);
	const before = config.events.length;
	config.events = config.events.filter((e) => {
		if (!e.time) return true;
		const relevantTime = e.endTime ? new Date(e.endTime) : new Date(e.time);
		return relevantTime >= cutoff;
	});
	return before - config.events.length;
}

/**
 * Check if a config should be archived (endDate < today).
 */
export function shouldArchive(config, now = new Date()) {
	if (!config.endDate) return false;
	const end = new Date(config.endDate);
	const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
	return end < today;
}

/**
 * Check if a config needs research (autoGenerated with empty events).
 */
export function shouldResearch(config) {
	return config.autoGenerated === true && (!Array.isArray(config.events) || config.events.length === 0);
}

/**
 * Check if a config file is a curated event config (not user-context, etc.).
 */
function isEventConfig(config, filename) {
	if (filename === "user-context.json") return false;
	// Event configs have a name field or are arrays (chess-tournaments, golfers)
	// Skip array configs (norwegian-golfers, chess-tournaments) — they're roster files
	if (Array.isArray(config)) return false;
	return typeof config.name === "string";
}

/**
 * Main orchestrator: prune, archive, and flag configs.
 */
export function syncConfigs({ configDir, archiveDir, now } = {}) {
	const cfgDir = configDir || defaultConfigDir;
	const arcDir = archiveDir || defaultArchiveDir;
	const timestamp = now || new Date();

	const result = { pruned: 0, archived: [], flagged: [], rosterSynced: [], errors: [] };

	if (!fs.existsSync(cfgDir)) {
		console.log("No config directory found — nothing to sync.");
		return result;
	}

	const files = fs.readdirSync(cfgDir).filter((f) => f.endsWith(".json"));

	for (const file of files) {
		const filePath = path.join(cfgDir, file);
		const config = readJsonIfExists(filePath);
		if (!config || !isEventConfig(config, file)) continue;

		try {
			// 1. Archive expired configs
			if (shouldArchive(config, timestamp)) {
				if (!fs.existsSync(arcDir)) {
					fs.mkdirSync(arcDir, { recursive: true });
				}
				const archivePath = path.join(arcDir, file);
				fs.renameSync(filePath, archivePath);
				result.archived.push(file);
				console.log(`  Archived: ${file} (endDate ${config.endDate} is past)`);
				continue;
			}

			let modified = false;

			// 2. Prune expired events
			const prunedCount = pruneExpiredEvents(config, timestamp);
			if (prunedCount > 0) {
				result.pruned += prunedCount;
				modified = true;
				console.log(`  Pruned ${prunedCount} expired events from ${file}`);
			}

			// 3. Sync per-event norwegianPlayers with top-level roster
			if (Array.isArray(config.norwegianAthletes) && Array.isArray(config.events)) {
				const beforeSync = JSON.stringify(config.events);
				syncEventPlayers(config);
				if (JSON.stringify(config.events) !== beforeSync) {
					modified = true;
					result.rosterSynced.push(file);
					console.log(`  Roster-synced: ${file} (per-event players updated)`);
				}
			}

			// 4. Flag needsResearch
			if (shouldResearch(config) && !config.needsResearch) {
				config.needsResearch = true;
				modified = true;
				result.flagged.push(file);
				console.log(`  Flagged: ${file} needs research (autoGenerated, empty events)`);
			}

			if (modified) {
				writeJsonPretty(filePath, config);
			}
		} catch (err) {
			result.errors.push(`${file}: ${err.message}`);
			console.error(`  Error processing ${file}:`, err.message);
		}
	}

	console.log(`\nSync complete: ${result.pruned} events pruned, ${result.archived.length} archived, ${result.flagged.length} flagged, ${result.rosterSynced.length} roster-synced`);
	return result;
}

/**
 * Write sync log to data directory.
 */
function writeSyncLog(result, dataDir) {
	const logPath = path.join(dataDir, "config-sync-log.json");
	const existing = readJsonIfExists(logPath) || { runs: [] };
	existing.runs.push({
		timestamp: iso(),
		...result,
	});
	// Keep last 50 runs
	while (existing.runs.length > 50) existing.runs.shift();
	writeJsonPretty(logPath, existing);
}

async function main() {
	console.log("Syncing configs...");
	const result = syncConfigs();
	const dataDir = rootDataPath();
	writeSyncLog(result, dataDir);
}

if (process.argv[1]?.includes("sync-configs")) {
	main().catch((err) => {
		console.error("Config sync failed:", err);
		process.exit(1);
	});
}
