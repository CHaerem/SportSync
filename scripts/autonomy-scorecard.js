import fs from "fs";
import path from "path";
import { readJsonIfExists, writeJsonPretty, iso, MS_PER_HOUR, MS_PER_DAY } from "./lib/helpers.js";

const ROOT = path.resolve(process.cwd(), "docs", "data");
const SCRIPTS = path.resolve(process.cwd(), "scripts");

function fileAgeMsOrNull(filePath) {
	try {
		const stat = fs.statSync(filePath);
		return Date.now() - stat.mtimeMs;
	} catch {
		return null;
	}
}

function makeLoop(score, details) {
	const status = score >= 1.0 ? "closed" : score > 0 ? "partial" : "open";
	return { score, status, details };
}

// Loop 1: Featured Quality
// observe: quality-history.json -> decide: buildAdaptiveHints -> act: inject into prompt
export function evaluateFeaturedQuality(dataDir = ROOT) {
	const historyPath = path.join(dataDir, "quality-history.json");
	const history = readJsonIfExists(historyPath);

	if (!Array.isArray(history) || history.length === 0) {
		return makeLoop(0, "No quality history file found");
	}

	if (history.length < 3) {
		return makeLoop(0, `Only ${history.length} history entries (need >= 3)`);
	}

	// Check if the hints pipeline is wired (hintsApplied field exists in entries)
	const wiredEntries = history.filter((entry) => "hintsApplied" in entry);
	const hintsCount = history.filter(
		(entry) => Array.isArray(entry.hintsApplied) && entry.hintsApplied.length > 0
	).length;

	if (wiredEntries.length > 0) {
		// Loop is wired — hints field exists. Whether they fired depends on quality.
		if (hintsCount > 0) {
			return makeLoop(1.0, `${history.length} entries, hints fired ${hintsCount} times`);
		}
		return makeLoop(1.0, `${history.length} entries, hints wired and ready (quality is good)`);
	}

	return makeLoop(0.5, `${history.length} history entries but hints pipeline not wired`);
}

// Loop 2: Enrichment Quality
// observe: ai-quality.json -> decide: buildEnrichmentHints -> act: inject into prompt
export function evaluateEnrichmentQuality(dataDir = ROOT) {
	const qualityPath = path.join(dataDir, "ai-quality.json");
	const quality = readJsonIfExists(qualityPath);

	if (!quality || !quality.enrichment) {
		return makeLoop(0, "No enrichment quality data found");
	}

	if (quality.enrichment.hintsApplied !== undefined) {
		return makeLoop(1.0, `Enrichment hints tracked (${(quality.enrichment.hintsApplied || []).length} applied)`);
	}

	return makeLoop(0.5, "Quality data exists but hints not yet tracked");
}

// Loop 3: Coverage Gaps
// observe: coverage-gaps.json -> decide: resolve-coverage-gaps.js -> act: create config
export function evaluateCoverageGaps(dataDir = ROOT, scriptsDir = SCRIPTS) {
	let score = 0;
	const parts = [];

	const gapsPath = path.join(dataDir, "coverage-gaps.json");
	const gaps = readJsonIfExists(gapsPath);
	const gapAge = fileAgeMsOrNull(gapsPath);

	if (gaps && gapAge !== null && gapAge < MS_PER_DAY) {
		score += 0.33;
		parts.push("Gap detection works");
	} else if (gaps) {
		parts.push("Gap detection exists but data is stale");
	} else {
		parts.push("No coverage gaps data");
	}

	const resolverPath = path.join(scriptsDir, "resolve-coverage-gaps.js");
	if (fs.existsSync(resolverPath)) {
		score += 0.33;
		parts.push("resolver exists");
	} else {
		parts.push("no resolver script");
	}

	// Check if any config has autoGenerated: true
	const configDir = path.join(scriptsDir, "config");
	let hasAutoConfig = false;
	try {
		const configFiles = fs.readdirSync(configDir).filter((f) => f.endsWith(".json"));
		for (const file of configFiles) {
			const config = readJsonIfExists(path.join(configDir, file));
			if (config && config.autoGenerated === true) {
				hasAutoConfig = true;
				break;
			}
		}
	} catch {
		// config dir may not exist
	}

	if (hasAutoConfig) {
		score += 0.34;
		parts.push("auto-generated configs exist");
	} else if (score >= 0.66) {
		// Gap detection works + resolver exists = loop is wired and ready.
		// No auto-configs means there are no gaps to resolve — that's good coverage.
		const gapCount = gaps?.summary?.totalGapsDetected ?? gaps?.gaps?.length ?? 0;
		if (gapCount === 0) {
			score = 1.0;
			parts.push("no gaps to resolve (full coverage)");
		} else {
			parts.push(`${gapCount} unresolved gaps`);
		}
	} else {
		parts.push("no auto-configs yet");
	}

	// Round to avoid floating point issues
	score = Math.round(score * 100) / 100;

	return makeLoop(score, parts.join(", "));
}

// Loop 4: Pipeline Health
// observe: health-report.json -> decide: autopilot reads it -> act: repair tasks
export function evaluatePipelineHealth(dataDir = ROOT) {
	const reportPath = path.join(dataDir, "health-report.json");
	const report = readJsonIfExists(reportPath);

	if (!report) {
		return makeLoop(0, "No health report found");
	}

	const ageMs = fileAgeMsOrNull(reportPath);
	if (ageMs === null) {
		return makeLoop(0, "Cannot determine health report age");
	}

	const ageHours = Math.round(ageMs / MS_PER_HOUR);
	const ageMinutes = Math.round(ageMs / 60000);

	if (ageMs < 6 * MS_PER_HOUR) {
		const label = ageMinutes < 60 ? `${ageMinutes} min` : `${ageHours}h`;
		return makeLoop(1.0, `Health report is fresh (${label} old)`);
	}

	return makeLoop(0.5, `Health report exists but is stale (${ageHours}h old)`);
}

// Loop 5: Watch Plan
// observe: watch-plan.json -> decide: scoring algorithm -> act: display in UI
export function evaluateWatchPlan(dataDir = ROOT) {
	const planPath = path.join(dataDir, "watch-plan.json");
	const plan = readJsonIfExists(planPath);

	if (!plan || !Array.isArray(plan.picks) || plan.picks.length === 0) {
		return makeLoop(0, "No watch plan data or no picks");
	}

	const picksWithReasons = plan.picks.filter(
		(p) => Array.isArray(p.reasons) && p.reasons.length > 0
	);

	// Streaming is legitimately empty when events don't have broadcast info.
	// The loop is closed if picks exist with scored reasons (the observe→decide→act path works).
	if (picksWithReasons.length > 0) {
		const streamingCount = plan.picks.filter(
			(p) => Array.isArray(p.streaming) && p.streaming.length > 0
		).length;
		const streamNote = streamingCount > 0 ? ` (${streamingCount} with streaming)` : "";
		return makeLoop(1.0, `${plan.picks.length} picks with reasons${streamNote}`);
	}

	return makeLoop(0.5, `${plan.picks.length} picks but missing reasons data`);
}

// Loop 6: Code Health
// observe: autopilot scouting -> decide: AUTOPILOT_ROADMAP.md -> act: PRs merged
export function evaluateCodeHealth(rootDir = process.cwd()) {
	const roadmapPath = path.join(rootDir, "AUTOPILOT_ROADMAP.md");
	const logPath = path.join(rootDir, "docs", "data", "autopilot-log.json");

	const roadmapExists = fs.existsSync(roadmapPath);
	if (!roadmapExists) {
		return makeLoop(0, "No autopilot roadmap found");
	}

	const log = readJsonIfExists(logPath);
	const completedRuns = Array.isArray(log?.runs)
		? log.runs.filter((r) => r.outcome === "completed")
		: [];

	if (completedRuns.length > 0) {
		return makeLoop(1.0, `${completedRuns.length} completed tasks in autopilot log`);
	}

	return makeLoop(0.5, "Roadmap exists but no completed autopilot tasks logged");
}

// Loop 7: Event Discovery
// observe: discovery-log.json -> decide: needsResearch flags -> act: populate configs
export function evaluateEventDiscovery(dataDir = ROOT, scriptsDir = SCRIPTS) {
	let score = 0;
	const parts = [];

	// Check: discovery-log.json exists and is recent
	const logPath = path.join(dataDir, "discovery-log.json");
	const log = readJsonIfExists(logPath);
	if (log && Array.isArray(log.runs) && log.runs.length > 0) {
		score += 0.33;
		parts.push("discovery log exists");
	} else {
		parts.push("no discovery log");
	}

	// Check: sync-configs.js exists
	const syncPath = path.join(scriptsDir, "sync-configs.js");
	if (fs.existsSync(syncPath)) {
		score += 0.33;
		parts.push("sync-configs exists");
	} else {
		parts.push("no sync-configs script");
	}

	// Check: at least one config has lastResearched (discovery has run)
	const configDir = path.join(scriptsDir, "config");
	let hasResearchedConfig = false;
	try {
		const configFiles = fs.readdirSync(configDir).filter((f) => f.endsWith(".json"));
		for (const file of configFiles) {
			const config = readJsonIfExists(path.join(configDir, file));
			if (config && config.lastResearched) {
				hasResearchedConfig = true;
				break;
			}
		}
	} catch {
		// config dir may not exist
	}

	if (hasResearchedConfig) {
		score += 0.34;
		parts.push("configs have been researched");
	} else if (score >= 0.66) {
		// Both scripts exist but discovery hasn't run yet — check if there's work to do
		parts.push("discovery not yet run");
	} else {
		parts.push("no researched configs");
	}

	score = Math.round(score * 100) / 100;
	return makeLoop(score, parts.join(", "));
}

// Loop 8: Schedule Verification
// observe: verification-history.json -> decide: buildVerificationHints -> act: inject into discovery prompt
export function evaluateScheduleVerification(dataDir = ROOT, scriptsDir = SCRIPTS) {
	let score = 0;
	const parts = [];

	// 0.33 if verification-history.json exists and is recent
	const historyPath = path.join(dataDir, "verification-history.json");
	const history = readJsonIfExists(historyPath);
	const historyAge = fileAgeMsOrNull(historyPath);
	if (history && Array.isArray(history.runs) && history.runs.length > 0 && historyAge !== null && historyAge < MS_PER_DAY) {
		score += 0.33;
		parts.push("verification history exists and is fresh");
	} else if (history && Array.isArray(history.runs) && history.runs.length > 0) {
		parts.push("verification history exists but is stale");
	} else {
		parts.push("no verification history");
	}

	// 0.33 if schedule-verifier.js exists
	const verifierPath = path.join(scriptsDir, "lib", "schedule-verifier.js");
	if (fs.existsSync(verifierPath)) {
		score += 0.33;
		parts.push("schedule-verifier exists");
	} else {
		parts.push("no schedule-verifier module");
	}

	// 0.34 if at least one config has verificationSummary
	const configDir = path.join(scriptsDir, "config");
	let hasVerifiedConfig = false;
	try {
		const configFiles = fs.readdirSync(configDir).filter((f) => f.endsWith(".json"));
		for (const file of configFiles) {
			const config = readJsonIfExists(path.join(configDir, file));
			if (config && config.verificationSummary) {
				hasVerifiedConfig = true;
				break;
			}
		}
	} catch {
		// config dir may not exist
	}

	if (hasVerifiedConfig) {
		score += 0.34;
		parts.push("configs have verification summaries");
	} else if (score >= 0.66) {
		// Both exist but verification hasn't run yet
		parts.push("verification not yet applied to configs");
	} else {
		parts.push("no verified configs");
	}

	score = Math.round(score * 100) / 100;
	return makeLoop(score, parts.join(", "));
}

// Generate next-actions suggestions for open/partial loops
function buildNextActions(loops) {
	const actions = [];

	if (loops.featuredQuality.score < 1.0) {
		if (loops.featuredQuality.score === 0) {
			actions.push("Run pipeline to generate quality history data (need >= 3 entries)");
		} else {
			actions.push("Wire hintsApplied field into quality history snapshots");
		}
	}

	if (loops.enrichmentQuality.score < 1.0) {
		if (loops.enrichmentQuality.score === 0) {
			actions.push("Run enrichment pipeline to generate ai-quality.json with enrichment data");
		} else {
			actions.push("Add hintsApplied tracking to enrichment pipeline");
		}
	}

	if (loops.coverageGaps.score < 1.0) {
		if (loops.coverageGaps.score < 0.33) {
			actions.push("Run detect-coverage-gaps.js to generate fresh coverage gap data");
		}
		if (loops.coverageGaps.score < 0.66) {
			actions.push("Create scripts/resolve-coverage-gaps.js to auto-resolve detected gaps");
		}
		if (loops.coverageGaps.score < 1.0) {
			actions.push("Run resolve-coverage-gaps.js to create first auto-generated config");
		}
	}

	if (loops.pipelineHealth.score < 1.0) {
		if (loops.pipelineHealth.score === 0) {
			actions.push("Run pipeline-health.js to generate health report");
		} else {
			actions.push("Run pipeline more frequently to keep health report fresh (< 6h)");
		}
	}

	if (loops.watchPlan.score < 1.0) {
		if (loops.watchPlan.score === 0) {
			actions.push("Run watch plan generation to create watch-plan.json with picks");
		} else {
			actions.push("Ensure watch plan picks include both reasons and streaming arrays");
		}
	}

	if (loops.codeHealth.score < 1.0) {
		if (loops.codeHealth.score === 0) {
			actions.push("Create AUTOPILOT_ROADMAP.md with improvement tasks");
		} else {
			actions.push("Run autopilot workflow to complete roadmap tasks and log results");
		}
	}

	if (loops.eventDiscovery.score < 1.0) {
		if (loops.eventDiscovery.score < 0.33) {
			actions.push("Run discover-events.js to generate discovery log");
		}
		if (loops.eventDiscovery.score < 0.66) {
			actions.push("Create scripts/sync-configs.js for config maintenance");
		}
		if (loops.eventDiscovery.score < 1.0) {
			actions.push("Run discovery to populate at least one config with lastResearched");
		}
	}

	if (loops.scheduleVerification && loops.scheduleVerification.score < 1.0) {
		if (loops.scheduleVerification.score < 0.33) {
			actions.push("Run verify-schedules.js to generate verification history");
		}
		if (loops.scheduleVerification.score < 0.66) {
			actions.push("Ensure scripts/lib/schedule-verifier.js exists with verification engine");
		}
		if (loops.scheduleVerification.score < 1.0) {
			actions.push("Run verification to apply verificationSummary to at least one config");
		}
	}

	return actions;
}

export function evaluateAutonomy({ dataDir = ROOT, scriptsDir = SCRIPTS, rootDir = process.cwd() } = {}) {
	const loops = {
		featuredQuality: evaluateFeaturedQuality(dataDir),
		enrichmentQuality: evaluateEnrichmentQuality(dataDir),
		coverageGaps: evaluateCoverageGaps(dataDir, scriptsDir),
		pipelineHealth: evaluatePipelineHealth(dataDir),
		watchPlan: evaluateWatchPlan(dataDir),
		codeHealth: evaluateCodeHealth(rootDir),
		eventDiscovery: evaluateEventDiscovery(dataDir, scriptsDir),
		scheduleVerification: evaluateScheduleVerification(dataDir, scriptsDir),
	};

	const scores = Object.values(loops).map((l) => l.score);
	const overallScore = Math.round((scores.reduce((a, b) => a + b, 0) / scores.length) * 100) / 100;
	const loopsClosed = scores.filter((s) => s >= 1.0).length;

	const nextActions = buildNextActions(loops);

	return {
		generatedAt: iso(),
		overallScore,
		loopsClosed,
		loopsTotal: scores.length,
		loops,
		nextActions,
	};
}

// CLI entry point
const isMain = process.argv[1] && path.resolve(process.argv[1]) === path.resolve(new URL(import.meta.url).pathname);
if (isMain) {
	const report = evaluateAutonomy();
	const outPath = path.join(ROOT, "autonomy-report.json");
	writeJsonPretty(outPath, report);
	console.log(`Autonomy Report: ${report.overallScore * 100}% (${report.loopsClosed}/${report.loopsTotal} loops closed)`);
	for (const [name, loop] of Object.entries(report.loops)) {
		const icon = loop.status === "closed" ? "[OK]" : loop.status === "partial" ? "[~~]" : "[  ]";
		console.log(`  ${icon} ${name}: ${loop.score} - ${loop.details}`);
	}
	if (report.nextActions.length > 0) {
		console.log("\nNext actions:");
		for (const action of report.nextActions) {
			console.log(`  -> ${action}`);
		}
	}
}
