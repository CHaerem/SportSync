import fs from "fs";
import path from "path";
import { readJsonIfExists, writeJsonPretty, iso, MS_PER_HOUR, MS_PER_DAY } from "./lib/helpers.js";

const ROOT = path.resolve(process.cwd(), "docs", "data");
const SCRIPTS = path.resolve(process.cwd(), "scripts");

function fileAgeMsOrNull(filePath) {
	try {
		const stat = fs.statSync(filePath);
		return Date.now() - stat.mtimeMs;
	} catch {
		return null;
	}
}

function makeLoop(score, details) {
	const status = score >= 1.0 ? "closed" : score > 0 ? "partial" : "open";
	return { score, status, details };
}

// Loop 1: Featured Quality
// observe: quality-history.json -> decide: buildAdaptiveHints -> act: inject into prompt
export function evaluateFeaturedQuality(dataDir = ROOT) {
	const historyPath = path.join(dataDir, "quality-history.json");
	const history = readJsonIfExists(historyPath);

	if (!Array.isArray(history) || history.length === 0) {
		return makeLoop(0, "No quality history file found");
	}

	if (history.length < 3) {
		return makeLoop(0, `Only ${history.length} history entries (need >= 3)`);
	}

	// Check if the hints pipeline is wired (hintsApplied field exists in entries)
	const wiredEntries = history.filter((entry) => "hintsApplied" in entry);
	const hintsCount = history.filter(
		(entry) => Array.isArray(entry.hintsApplied) && entry.hintsApplied.length > 0
	).length;

	if (wiredEntries.length > 0) {
		// Loop is wired — hints field exists. Whether they fired depends on quality.
		if (hintsCount > 0) {
			// Check if hints are firing without improving the metric
			const recent = history.slice(-5);
			const recentEditorial = recent
				.map((e) => e.editorial?.mustWatchCoverage ?? null)
				.filter((v) => v !== null);
			const IMPROVEMENT_THRESHOLD = 0.6;
			const stillBelowThreshold = recentEditorial.length >= 3 &&
				recentEditorial.every((v) => v < IMPROVEMENT_THRESHOLD);

			if (stillBelowThreshold) {
				return makeLoop(0.75, `${history.length} entries, hints fired ${hintsCount} times but metric not improving`);
			}
			return makeLoop(1.0, `${history.length} entries, hints fired ${hintsCount} times`);
		}
		return makeLoop(1.0, `${history.length} entries, hints wired and ready (quality is good)`);
	}

	return makeLoop(0.5, `${history.length} history entries but hints pipeline not wired`);
}

// Loop 2: Enrichment Quality
// observe: ai-quality.json -> decide: buildEnrichmentHints -> act: inject into prompt
export function evaluateEnrichmentQuality(dataDir = ROOT) {
	const qualityPath = path.join(dataDir, "ai-quality.json");
	const quality = readJsonIfExists(qualityPath);

	if (!quality || !quality.enrichment) {
		return makeLoop(0, "No enrichment quality data found");
	}

	if (quality.enrichment.hintsApplied !== undefined) {
		return makeLoop(1.0, `Enrichment hints tracked (${(quality.enrichment.hintsApplied || []).length} applied)`);
	}

	return makeLoop(0.5, "Quality data exists but hints not yet tracked");
}

// Loop 3: Coverage Gaps
// observe: coverage-gaps.json -> decide: resolve-coverage-gaps.js -> act: create config
export function evaluateCoverageGaps(dataDir = ROOT, scriptsDir = SCRIPTS) {
	let score = 0;
	const parts = [];

	const gapsPath = path.join(dataDir, "coverage-gaps.json");
	const gaps = readJsonIfExists(gapsPath);
	const gapAge = fileAgeMsOrNull(gapsPath);

	if (gaps && gapAge !== null && gapAge < MS_PER_DAY) {
		score += 0.33;
		parts.push("Gap detection works");
	} else if (gaps) {
		parts.push("Gap detection exists but data is stale");
	} else {
		parts.push("No coverage gaps data");
	}

	const resolverPath = path.join(scriptsDir, "resolve-coverage-gaps.js");
	if (fs.existsSync(resolverPath)) {
		score += 0.33;
		parts.push("resolver exists");
	} else {
		parts.push("no resolver script");
	}

	// Check if any config has autoGenerated: true
	const configDir = path.join(scriptsDir, "config");
	let hasAutoConfig = false;
	try {
		const configFiles = fs.readdirSync(configDir).filter((f) => f.endsWith(".json"));
		for (const file of configFiles) {
			const config = readJsonIfExists(path.join(configDir, file));
			if (config && config.autoGenerated === true) {
				hasAutoConfig = true;
				break;
			}
		}
	} catch {
		// config dir may not exist
	}

	if (hasAutoConfig) {
		score += 0.34;
		parts.push("auto-generated configs exist");
	} else if (score >= 0.66) {
		// Gap detection works + resolver exists = loop is wired and ready.
		// No auto-configs means there are no gaps to resolve — that's good coverage.
		const gapCount = gaps?.summary?.totalGapsDetected ?? gaps?.gaps?.length ?? 0;
		if (gapCount === 0) {
			score = 1.0;
			parts.push("no gaps to resolve (full coverage)");
		} else {
			parts.push(`${gapCount} unresolved gaps`);
		}
	} else {
		parts.push("no auto-configs yet");
	}

	// Round to avoid floating point issues
	score = Math.round(score * 100) / 100;

	return makeLoop(score, parts.join(", "));
}

// Loop 4: Pipeline Health
// observe: health-report.json -> decide: autopilot reads it -> act: repair tasks
export function evaluatePipelineHealth(dataDir = ROOT) {
	const reportPath = path.join(dataDir, "health-report.json");
	const report = readJsonIfExists(reportPath);

	if (!report) {
		return makeLoop(0, "No health report found");
	}

	const ageMs = fileAgeMsOrNull(reportPath);
	if (ageMs === null) {
		return makeLoop(0, "Cannot determine health report age");
	}

	const ageHours = Math.round(ageMs / MS_PER_HOUR);
	const ageMinutes = Math.round(ageMs / 60000);

	if (ageMs < 6 * MS_PER_HOUR) {
		const label = ageMinutes < 60 ? `${ageMinutes} min` : `${ageHours}h`;
		// Only count actionable issues (warning/critical, excluding known data-availability patterns)
		const KNOWN_DATA_GAPS = new Set(["sport_zero_events", "quota_api_unavailable"]);
		const actionableIssues = Array.isArray(report.issues)
			? report.issues.filter(i => i.severity !== "info" && !KNOWN_DATA_GAPS.has(i.code))
			: [];
		const totalIssues = Array.isArray(report.issues) ? report.issues.length : 0;
		if (actionableIssues.length > 0) {
			return makeLoop(0.75, `Health report is fresh (${label} old) but has ${actionableIssues.length} actionable issue(s) (${totalIssues} total)`);
		}
		return makeLoop(1.0, `Health report is fresh (${label} old), ${totalIssues} issue(s) are info/known`);
	}

	return makeLoop(0.5, `Health report exists but is stale (${ageHours}h old)`);
}

// Loop 5: Watch Plan
// observe: watch-plan.json -> decide: scoring algorithm -> act: display in UI
export function evaluateWatchPlan(dataDir = ROOT) {
	const planPath = path.join(dataDir, "watch-plan.json");
	const plan = readJsonIfExists(planPath);

	if (!plan || !Array.isArray(plan.picks) || plan.picks.length === 0) {
		return makeLoop(0, "No watch plan data or no picks");
	}

	const picksWithReasons = plan.picks.filter(
		(p) => Array.isArray(p.reasons) && p.reasons.length > 0
	);

	// Streaming is legitimately empty when events don't have broadcast info.
	// The loop is closed if picks exist with scored reasons (the observe→decide→act path works).
	if (picksWithReasons.length > 0) {
		const streamingCount = plan.picks.filter(
			(p) => Array.isArray(p.streaming) && p.streaming.length > 0
		).length;
		const streamNote = streamingCount > 0 ? ` (${streamingCount} with streaming)` : "";
		return makeLoop(1.0, `${plan.picks.length} picks with reasons${streamNote}`);
	}

	return makeLoop(0.5, `${plan.picks.length} picks but missing reasons data`);
}

// Loop 6: Code Health
// observe: autopilot scouting -> decide: AUTOPILOT_ROADMAP.md -> act: PRs merged
export function evaluateCodeHealth(rootDir = process.cwd()) {
	const roadmapPath = path.join(rootDir, "AUTOPILOT_ROADMAP.md");
	const logPath = path.join(rootDir, "docs", "data", "autopilot-log.json");

	const roadmapExists = fs.existsSync(roadmapPath);
	if (!roadmapExists) {
		return makeLoop(0, "No autopilot roadmap found");
	}

	const log = readJsonIfExists(logPath);
	const completedRuns = Array.isArray(log?.runs)
		? log.runs.filter((r) => r.outcome === "completed")
		: [];

	if (completedRuns.length > 0) {
		return makeLoop(1.0, `${completedRuns.length} completed tasks in autopilot log`);
	}

	return makeLoop(0.5, "Roadmap exists but no completed autopilot tasks logged");
}

// Loop 7: Event Discovery
// observe: discovery-log.json -> decide: needsResearch flags -> act: populate configs
export function evaluateEventDiscovery(dataDir = ROOT, scriptsDir = SCRIPTS) {
	let score = 0;
	const parts = [];

	// Check: discovery-log.json exists and is recent
	const logPath = path.join(dataDir, "discovery-log.json");
	const log = readJsonIfExists(logPath);
	if (log && Array.isArray(log.runs) && log.runs.length > 0) {
		score += 0.33;
		parts.push("discovery log exists");
	} else {
		parts.push("no discovery log");
	}

	// Check: sync-configs.js exists
	const syncPath = path.join(scriptsDir, "sync-configs.js");
	if (fs.existsSync(syncPath)) {
		score += 0.33;
		parts.push("sync-configs exists");
	} else {
		parts.push("no sync-configs script");
	}

	// Check: at least one config has lastResearched (discovery has run)
	const configDir = path.join(scriptsDir, "config");
	let hasResearchedConfig = false;
	try {
		const configFiles = fs.readdirSync(configDir).filter((f) => f.endsWith(".json"));
		for (const file of configFiles) {
			const config = readJsonIfExists(path.join(configDir, file));
			if (config && config.lastResearched) {
				hasResearchedConfig = true;
				break;
			}
		}
	} catch {
		// config dir may not exist
	}

	if (hasResearchedConfig) {
		score += 0.34;
		parts.push("configs have been researched");
	} else if (score >= 0.66) {
		// Both scripts exist but discovery hasn't run yet — check if there's work to do
		parts.push("discovery not yet run");
	} else {
		parts.push("no researched configs");
	}

	score = Math.round(score * 100) / 100;
	return makeLoop(score, parts.join(", "));
}

// Loop 8: Schedule Verification
// observe: verification-history.json -> decide: buildVerificationHints -> act: inject into discovery prompt
export function evaluateScheduleVerification(dataDir = ROOT, scriptsDir = SCRIPTS) {
	let score = 0;
	const parts = [];

	// 0.33 if verification-history.json exists and is recent
	const historyPath = path.join(dataDir, "verification-history.json");
	const history = readJsonIfExists(historyPath);
	const historyAge = fileAgeMsOrNull(historyPath);
	if (history && Array.isArray(history.runs) && history.runs.length > 0 && historyAge !== null && historyAge < MS_PER_DAY) {
		score += 0.33;
		parts.push("verification history exists and is fresh");
	} else if (history && Array.isArray(history.runs) && history.runs.length > 0) {
		parts.push("verification history exists but is stale");
	} else {
		parts.push("no verification history");
	}

	// 0.33 if schedule-verifier.js exists
	const verifierPath = path.join(scriptsDir, "lib", "schedule-verifier.js");
	if (fs.existsSync(verifierPath)) {
		score += 0.33;
		parts.push("schedule-verifier exists");
	} else {
		parts.push("no schedule-verifier module");
	}

	// 0.34 if at least one config has verificationSummary
	const configDir = path.join(scriptsDir, "config");
	let hasVerifiedConfig = false;
	try {
		const configFiles = fs.readdirSync(configDir).filter((f) => f.endsWith(".json"));
		for (const file of configFiles) {
			const config = readJsonIfExists(path.join(configDir, file));
			if (config && config.verificationSummary) {
				hasVerifiedConfig = true;
				break;
			}
		}
	} catch {
		// config dir may not exist
	}

	if (hasVerifiedConfig) {
		score += 0.34;
		parts.push("configs have verification summaries");
	} else if (score >= 0.66) {
		// Both exist but verification hasn't run yet
		parts.push("verification not yet applied to configs");
	} else {
		parts.push("no verified configs");
	}

	score = Math.round(score * 100) / 100;
	return makeLoop(score, parts.join(", "));
}

// Loop 9: Results Health
// observe: recent-results.json -> decide: pipeline-health checks staleness -> act: health report surfaces issues
export function evaluateResultsHealth(dataDir = ROOT, scriptsDir = SCRIPTS) {
	let score = 0;
	const parts = [];

	// 0.33 if fetch-results.js exists
	const fetcherPath = path.join(scriptsDir, "fetch-results.js");
	if (fs.existsSync(fetcherPath)) {
		score += 0.33;
		parts.push("fetcher exists");
	} else {
		parts.push("no fetch-results.js");
	}

	// 0.33 if recent-results.json exists and is fresh (<6h)
	const resultsPath = path.join(dataDir, "recent-results.json");
	const results = readJsonIfExists(resultsPath);
	const resultsAge = fileAgeMsOrNull(resultsPath);

	if (results && resultsAge !== null && resultsAge < 6 * MS_PER_HOUR) {
		score += 0.33;
		parts.push("results data is fresh");
	} else if (results) {
		parts.push("results data exists but is stale");
	} else {
		parts.push("no results data");
	}

	// 0.34 if pipeline-health monitors results (resultsHealth field in health-report.json)
	const reportPath = path.join(dataDir, "health-report.json");
	const report = readJsonIfExists(reportPath);
	if (report && report.resultsHealth) {
		score += 0.34;
		parts.push("pipeline monitors results health");
	} else if (report) {
		parts.push("health report exists but doesn't monitor results");
	} else {
		parts.push("no health report");
	}

	score = Math.round(score * 100) / 100;
	return makeLoop(score, parts.join(", "));
}

// Loop 10: Snapshot Health
// observe: docs/data/days/_meta.json -> decide: pipeline-health checks snapshot issues -> act: autopilot repairs
export function evaluateSnapshotHealth(dataDir = ROOT) {
	let score = 0;
	const parts = [];

	// 0.33 if day snapshots directory exists with snapshots
	const metaPath = path.join(dataDir, "days", "_meta.json");
	const meta = readJsonIfExists(metaPath);
	if (meta && meta.snapshotCount > 0) {
		score += 0.33;
		parts.push(`${meta.snapshotCount} snapshots exist`);
	} else {
		parts.push("no day snapshots");
	}

	// 0.33 if pipeline-health checks snapshot issues (snapshotHealth field in health-report.json)
	const reportPath = path.join(dataDir, "health-report.json");
	const report = readJsonIfExists(reportPath);
	if (report && report.snapshotHealth) {
		score += 0.33;
		parts.push("pipeline monitors snapshot health");
	} else if (report) {
		parts.push("health report exists but doesn't monitor snapshots");
	} else {
		parts.push("no health report");
	}

	// 0.34 if snapshots are fresh (generated within 6h)
	const metaAge = fileAgeMsOrNull(metaPath);
	if (metaAge !== null && metaAge < 6 * MS_PER_HOUR) {
		score += 0.34;
		parts.push("snapshots are fresh");
	} else if (metaAge !== null) {
		parts.push("snapshots are stale");
	} else {
		parts.push("no snapshot metadata");
	}

	score = Math.round(score * 100) / 100;
	return makeLoop(score, parts.join(", "));
}

// Loop 11: Streaming Verification
// observe: streaming-verification-history.json -> decide: buildStreamingHints -> act: alias suggestions, trend analysis
export function evaluateStreamingVerification(dataDir = ROOT) {
	let score = 0;
	const parts = [];

	// 0.33 if streaming-verification-history.json exists and is fresh (<24h)
	const historyPath = path.join(dataDir, "streaming-verification-history.json");
	const history = readJsonIfExists(historyPath);
	const historyAge = fileAgeMsOrNull(historyPath);
	if (history?.runs?.length > 0 && historyAge !== null && historyAge < MS_PER_DAY) {
		score += 0.33;
		parts.push("verification history exists and is fresh");
	} else if (history?.runs?.length > 0) {
		parts.push("verification history exists but is stale");
	} else {
		parts.push("no streaming verification history");
	}

	// 0.33 if history has >= 3 runs (enough for trend analysis)
	if (history?.runs?.length >= 3) {
		score += 0.33;
		parts.push(`${history.runs.length} runs (trend-capable)`);
	} else if (history?.runs?.length > 0) {
		parts.push(`only ${history.runs.length} run(s) (need >= 3 for trend)`);
	} else {
		parts.push("no runs for trend analysis");
	}

	// 0.34 if match rate trend is stable or rising (not declining)
	if (history?.runs?.length >= 3) {
		const recent3 = history.runs.slice(-3);
		const rates = recent3.map((r) => r.matchRate ?? 0);
		const declining = rates.every((r, i) => i === 0 || r < rates[i - 1]);
		if (!declining) {
			score += 0.34;
			parts.push("match rate trend is stable or rising");
		} else {
			parts.push(`match rate declining: ${rates.map(r => Math.round(r * 100) + "%").join(" → ")}`);
		}
	} else {
		parts.push("insufficient data for trend assessment");
	}

	score = Math.round(score * 100) / 100;
	return makeLoop(score, parts.join(", "));
}

// Generate next-actions suggestions for open/partial loops
function buildNextActions(loops) {
	const actions = [];

	if (loops.featuredQuality.score < 1.0) {
		if (loops.featuredQuality.score === 0) {
			actions.push("Run pipeline to generate quality history data (need >= 3 entries)");
		} else {
			actions.push("Wire hintsApplied field into quality history snapshots");
		}
	}

	if (loops.enrichmentQuality.score < 1.0) {
		if (loops.enrichmentQuality.score === 0) {
			actions.push("Run enrichment pipeline to generate ai-quality.json with enrichment data");
		} else {
			actions.push("Add hintsApplied tracking to enrichment pipeline");
		}
	}

	if (loops.coverageGaps.score < 1.0) {
		if (loops.coverageGaps.score < 0.33) {
			actions.push("Run detect-coverage-gaps.js to generate fresh coverage gap data");
		}
		if (loops.coverageGaps.score < 0.66) {
			actions.push("Create scripts/resolve-coverage-gaps.js to auto-resolve detected gaps");
		}
		if (loops.coverageGaps.score < 1.0) {
			actions.push("Run resolve-coverage-gaps.js to create first auto-generated config");
		}
	}

	if (loops.pipelineHealth.score < 1.0) {
		if (loops.pipelineHealth.score === 0) {
			actions.push("Run pipeline-health.js to generate health report");
		} else {
			actions.push("Run pipeline more frequently to keep health report fresh (< 6h)");
		}
	}

	if (loops.watchPlan.score < 1.0) {
		if (loops.watchPlan.score === 0) {
			actions.push("Run watch plan generation to create watch-plan.json with picks");
		} else {
			actions.push("Ensure watch plan picks include both reasons and streaming arrays");
		}
	}

	if (loops.codeHealth.score < 1.0) {
		if (loops.codeHealth.score === 0) {
			actions.push("Create AUTOPILOT_ROADMAP.md with improvement tasks");
		} else {
			actions.push("Run autopilot workflow to complete roadmap tasks and log results");
		}
	}

	if (loops.eventDiscovery.score < 1.0) {
		if (loops.eventDiscovery.score < 0.33) {
			actions.push("Run discover-events.js to generate discovery log");
		}
		if (loops.eventDiscovery.score < 0.66) {
			actions.push("Create scripts/sync-configs.js for config maintenance");
		}
		if (loops.eventDiscovery.score < 1.0) {
			actions.push("Run discovery to populate at least one config with lastResearched");
		}
	}

	if (loops.scheduleVerification && loops.scheduleVerification.score < 1.0) {
		if (loops.scheduleVerification.score < 0.33) {
			actions.push("Run verify-schedules.js to generate verification history");
		}
		if (loops.scheduleVerification.score < 0.66) {
			actions.push("Ensure scripts/lib/schedule-verifier.js exists with verification engine");
		}
		if (loops.scheduleVerification.score < 1.0) {
			actions.push("Run verification to apply verificationSummary to at least one config");
		}
	}

	if (loops.resultsHealth && loops.resultsHealth.score < 1.0) {
		if (loops.resultsHealth.score < 0.33) {
			actions.push("Create scripts/fetch-results.js to fetch recent match results");
		}
		if (loops.resultsHealth.score < 0.66) {
			actions.push("Run fetch-results.js to generate fresh recent-results.json");
		}
		if (loops.resultsHealth.score < 1.0) {
			actions.push("Ensure pipeline-health.js monitors results freshness (resultsHealth field)");
		}
	}

	if (loops.snapshotHealth && loops.snapshotHealth.score < 1.0) {
		if (loops.snapshotHealth.score < 0.33) {
			actions.push("Run build-day-snapshots.js to generate day snapshot files");
		}
		if (loops.snapshotHealth.score < 0.66) {
			actions.push("Ensure pipeline-health.js monitors snapshot health (snapshotHealth field)");
		}
		if (loops.snapshotHealth.score < 1.0) {
			actions.push("Run pipeline more frequently to keep snapshots fresh (< 6h)");
		}
	}

	if (loops.streamingVerification && loops.streamingVerification.score < 1.0) {
		if (loops.streamingVerification.score < 0.33) {
			actions.push("Run enrich-streaming.js to generate streaming verification history");
		}
		if (loops.streamingVerification.score < 0.66) {
			actions.push("Run streaming enrichment 3+ times to build trend data");
		}
		if (loops.streamingVerification.score < 1.0) {
			actions.push("Investigate declining streaming match rate — check alias table or tvkampen HTML structure");
		}
	}

	return actions;
}

export function evaluateAutonomy({ dataDir = ROOT, scriptsDir = SCRIPTS, rootDir = process.cwd() } = {}) {
	const loops = {
		featuredQuality: evaluateFeaturedQuality(dataDir),
		enrichmentQuality: evaluateEnrichmentQuality(dataDir),
		coverageGaps: evaluateCoverageGaps(dataDir, scriptsDir),
		pipelineHealth: evaluatePipelineHealth(dataDir),
		watchPlan: evaluateWatchPlan(dataDir),
		codeHealth: evaluateCodeHealth(rootDir),
		eventDiscovery: evaluateEventDiscovery(dataDir, scriptsDir),
		scheduleVerification: evaluateScheduleVerification(dataDir, scriptsDir),
		resultsHealth: evaluateResultsHealth(dataDir, scriptsDir),
		snapshotHealth: evaluateSnapshotHealth(dataDir),
		streamingVerification: evaluateStreamingVerification(dataDir),
	};

	const scores = Object.values(loops).map((l) => l.score);
	const overallScore = Math.round((scores.reduce((a, b) => a + b, 0) / scores.length) * 100) / 100;
	const loopsClosed = scores.filter((s) => s >= 1.0).length;

	const nextActions = buildNextActions(loops);

	return {
		generatedAt: iso(),
		overallScore,
		loopsClosed,
		loopsTotal: scores.length,
		loops,
		nextActions,
	};
}

// Trend tracking — append autonomy snapshot to history file (max 30 entries)
export function trackTrend(report, dataDir = ROOT) {
	const trendPath = path.join(dataDir, "autonomy-trend.json");
	const existing = readJsonIfExists(trendPath) || [];

	const entry = {
		timestamp: report.generatedAt,
		overallScore: report.overallScore,
		loopsClosed: report.loopsClosed,
		loopsTotal: report.loopsTotal,
		loopScores: Object.fromEntries(
			Object.entries(report.loops).map(([k, v]) => [k, v.score])
		),
	};

	existing.push(entry);

	// Keep only last 30 entries
	const trimmed = existing.slice(-30);
	writeJsonPretty(trendPath, trimmed);
	return trimmed;
}

// Detect regressions — compare latest entry to previous
export function detectRegressions(trend) {
	if (!Array.isArray(trend) || trend.length < 2) return [];

	const prev = trend[trend.length - 2];
	const curr = trend[trend.length - 1];
	const regressions = [];

	if (curr.overallScore < prev.overallScore) {
		regressions.push(`Overall autonomy dropped from ${prev.overallScore} to ${curr.overallScore}`);
	}

	if (curr.loopScores && prev.loopScores) {
		for (const [loop, score] of Object.entries(curr.loopScores)) {
			const prevScore = prev.loopScores[loop];
			if (prevScore !== undefined && score < prevScore) {
				regressions.push(`${loop} regressed from ${prevScore} to ${score}`);
			}
		}
	}

	return regressions;
}

// CLI entry point
const isMain = process.argv[1] && path.resolve(process.argv[1]) === path.resolve(new URL(import.meta.url).pathname);
if (isMain) {
	const report = evaluateAutonomy();
	const outPath = path.join(ROOT, "autonomy-report.json");
	writeJsonPretty(outPath, report);
	console.log(`Autonomy Report: ${report.overallScore * 100}% (${report.loopsClosed}/${report.loopsTotal} loops closed)`);
	for (const [name, loop] of Object.entries(report.loops)) {
		const icon = loop.status === "closed" ? "[OK]" : loop.status === "partial" ? "[~~]" : "[  ]";
		console.log(`  ${icon} ${name}: ${loop.score} - ${loop.details}`);
	}
	if (report.nextActions.length > 0) {
		console.log("\nNext actions:");
		for (const action of report.nextActions) {
			console.log(`  -> ${action}`);
		}
	}
}
