import { describe, it, expect, beforeEach, afterEach } from "vitest";
import fs from "fs";
import path from "path";
import os from "os";
import {
	pruneExpiredEvents,
	shouldArchive,
	shouldResearch,
	syncConfigs,
	cleanupArchive,
} from "../scripts/sync-configs.js";

let tmpDir;
let configDir;
let archiveDir;

function writeJson(filePath, data) {
	fs.mkdirSync(path.dirname(filePath), { recursive: true });
	fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
}

beforeEach(() => {
	tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), "sync-configs-test-"));
	configDir = path.join(tmpDir, "config");
	archiveDir = path.join(tmpDir, "config", "archive");
	fs.mkdirSync(configDir, { recursive: true });
});

afterEach(() => {
	fs.rmSync(tmpDir, { recursive: true, force: true });
});

// --- pruneExpiredEvents ---

describe("pruneExpiredEvents()", () => {
	it("removes events older than 6 hours", () => {
		const now = new Date("2026-02-12T12:00:00Z");
		const config = {
			name: "Test",
			events: [
				{ title: "Old event", time: "2026-02-12T05:00:00Z" },
				{ title: "Recent event", time: "2026-02-12T07:00:00Z" },
				{ title: "Future event", time: "2026-02-12T18:00:00Z" },
			],
		};
		const pruned = pruneExpiredEvents(config, now);
		expect(pruned).toBe(1);
		expect(config.events).toHaveLength(2);
		expect(config.events[0].title).toBe("Recent event");
		expect(config.events[1].title).toBe("Future event");
	});

	it("returns 0 when no events to prune", () => {
		const now = new Date("2026-02-12T12:00:00Z");
		const config = {
			name: "Test",
			events: [
				{ title: "Future event", time: "2026-02-12T18:00:00Z" },
			],
		};
		const pruned = pruneExpiredEvents(config, now);
		expect(pruned).toBe(0);
		expect(config.events).toHaveLength(1);
	});

	it("handles config with no events array", () => {
		const config = { name: "Test" };
		const pruned = pruneExpiredEvents(config);
		expect(pruned).toBe(0);
	});

	it("keeps events without time field", () => {
		const now = new Date("2026-02-12T12:00:00Z");
		const config = {
			name: "Test",
			events: [
				{ title: "No time" },
				{ title: "Old", time: "2026-02-12T01:00:00Z" },
			],
		};
		const pruned = pruneExpiredEvents(config, now);
		expect(pruned).toBe(1);
		expect(config.events).toHaveLength(1);
		expect(config.events[0].title).toBe("No time");
	});
});

// --- shouldArchive ---

describe("shouldArchive()", () => {
	it("returns true when endDate is before today", () => {
		const config = { name: "Test", endDate: "2026-02-10" };
		const now = new Date("2026-02-12T12:00:00Z");
		expect(shouldArchive(config, now)).toBe(true);
	});

	it("returns false when endDate is today or later", () => {
		const config = { name: "Test", endDate: "2026-02-12" };
		const now = new Date("2026-02-12T12:00:00Z");
		expect(shouldArchive(config, now)).toBe(false);
	});

	it("returns false when no endDate", () => {
		const config = { name: "Test" };
		expect(shouldArchive(config)).toBe(false);
	});
});

// --- shouldResearch ---

describe("shouldResearch()", () => {
	it("returns true for autoGenerated config with empty events", () => {
		const config = { name: "Test", autoGenerated: true, events: [] };
		expect(shouldResearch(config)).toBe(true);
	});

	it("returns true for autoGenerated config with no events array", () => {
		const config = { name: "Test", autoGenerated: true };
		expect(shouldResearch(config)).toBe(true);
	});

	it("returns false for autoGenerated config with events", () => {
		const config = { name: "Test", autoGenerated: true, events: [{ title: "E" }] };
		expect(shouldResearch(config)).toBe(false);
	});

	it("returns false for non-autoGenerated config", () => {
		const config = { name: "Test", events: [] };
		expect(shouldResearch(config)).toBe(false);
	});
});

// --- syncConfigs ---

describe("syncConfigs()", () => {
	it("prunes expired events from configs", () => {
		const now = new Date("2026-02-12T12:00:00Z");
		writeJson(path.join(configDir, "test-event.json"), {
			name: "Test Event",
			sport: "football",
			endDate: "2026-03-01",
			events: [
				{ title: "Old", time: "2026-02-12T01:00:00Z" },
				{ title: "Future", time: "2026-02-12T18:00:00Z" },
			],
		});

		const result = syncConfigs({ configDir, archiveDir, now });
		expect(result.pruned).toBe(1);

		const updated = JSON.parse(fs.readFileSync(path.join(configDir, "test-event.json"), "utf-8"));
		expect(updated.events).toHaveLength(1);
		expect(updated.events[0].title).toBe("Future");
	});

	it("archives expired configs", () => {
		const now = new Date("2026-02-12T12:00:00Z");
		writeJson(path.join(configDir, "old-event.json"), {
			name: "Old Event",
			sport: "tennis",
			endDate: "2026-02-10",
			events: [],
		});

		const result = syncConfigs({ configDir, archiveDir, now });
		expect(result.archived).toContain("old-event.json");
		expect(fs.existsSync(path.join(archiveDir, "old-event.json"))).toBe(true);
		expect(fs.existsSync(path.join(configDir, "old-event.json"))).toBe(false);
	});

	it("flags autoGenerated configs with empty events", () => {
		const now = new Date("2026-02-12T12:00:00Z");
		writeJson(path.join(configDir, "skeleton.json"), {
			name: "Skeleton Config",
			sport: "golf",
			autoGenerated: true,
			endDate: "2026-03-01",
			events: [],
		});

		const result = syncConfigs({ configDir, archiveDir, now });
		expect(result.flagged).toContain("skeleton.json");

		const updated = JSON.parse(fs.readFileSync(path.join(configDir, "skeleton.json"), "utf-8"));
		expect(updated.needsResearch).toBe(true);
	});

	it("skips user-context.json", () => {
		writeJson(path.join(configDir, "user-context.json"), {
			favoriteTeams: ["Barcelona"],
		});

		const result = syncConfigs({ configDir, archiveDir });
		expect(result.pruned).toBe(0);
		expect(result.archived).toHaveLength(0);
		expect(result.flagged).toHaveLength(0);
	});

	it("skips array configs (roster files)", () => {
		writeJson(path.join(configDir, "norwegian-golfers.json"), [
			{ name: "Viktor Hovland" },
		]);

		const result = syncConfigs({ configDir, archiveDir });
		expect(result.pruned).toBe(0);
		expect(result.archived).toHaveLength(0);
	});

	it("handles missing config directory", () => {
		const result = syncConfigs({ configDir: "/nonexistent/dir", archiveDir });
		expect(result.pruned).toBe(0);
		expect(result.archived).toHaveLength(0);
		expect(result.flagged).toHaveLength(0);
	});

	it("does not re-flag already flagged configs", () => {
		writeJson(path.join(configDir, "flagged.json"), {
			name: "Already Flagged",
			autoGenerated: true,
			endDate: "2026-03-01",
			events: [],
			needsResearch: true,
		});

		const result = syncConfigs({ configDir, archiveDir });
		expect(result.flagged).toHaveLength(0);
	});

	it("syncs per-event norwegianPlayers with roster", () => {
		const now = new Date("2026-02-12T12:00:00Z");
		writeJson(path.join(configDir, "olympics.json"), {
			name: "Olympics",
			endDate: "2026-03-01",
			norwegianAthletes: ["Klaebo", "Kristoffersen"],
			events: [
				{
					title: "XC Men",
					time: "2026-02-13T10:00:00Z",
					norwegian: true,
					norwegianPlayers: [
						{ name: "Klaebo" },
						{ name: "Johaug" },
					],
				},
				{
					title: "Alpine",
					time: "2026-02-14T10:00:00Z",
					norwegian: true,
					norwegianPlayers: [{ name: "Kristoffersen" }],
				},
			],
		});

		const result = syncConfigs({ configDir, archiveDir, now });
		expect(result.rosterSynced).toContain("olympics.json");

		const updated = JSON.parse(fs.readFileSync(path.join(configDir, "olympics.json"), "utf-8"));
		// Johaug should be removed from XC Men (not in roster)
		expect(updated.events[0].norwegianPlayers).toHaveLength(1);
		expect(updated.events[0].norwegianPlayers[0].name).toBe("Klaebo");
		// Alpine should be unchanged
		expect(updated.events[1].norwegianPlayers).toHaveLength(1);
	});

	it("does not mark roster-synced when no changes needed", () => {
		const now = new Date("2026-02-12T12:00:00Z");
		writeJson(path.join(configDir, "clean.json"), {
			name: "Clean",
			endDate: "2026-03-01",
			norwegianAthletes: ["Klaebo"],
			events: [
				{
					title: "XC",
					time: "2026-02-13T10:00:00Z",
					norwegian: true,
					norwegianPlayers: [{ name: "Klaebo" }],
				},
			],
		});

		const result = syncConfigs({ configDir, archiveDir, now });
		expect(result.rosterSynced).toHaveLength(0);
	});

	it("sets norwegian=false when all players removed by roster sync", () => {
		const now = new Date("2026-02-12T12:00:00Z");
		writeJson(path.join(configDir, "stale.json"), {
			name: "Stale",
			endDate: "2026-03-01",
			norwegianAthletes: ["Klaebo"],
			events: [
				{
					title: "Event",
					time: "2026-02-13T10:00:00Z",
					norwegian: true,
					norwegianPlayers: [{ name: "Retired Player" }],
				},
			],
		});

		const result = syncConfigs({ configDir, archiveDir, now });
		expect(result.rosterSynced).toContain("stale.json");

		const updated = JSON.parse(fs.readFileSync(path.join(configDir, "stale.json"), "utf-8"));
		expect(updated.events[0].norwegianPlayers).toHaveLength(0);
		expect(updated.events[0].norwegian).toBe(false);
	});

	it("cleans up archived configs older than 90 days", () => {
		const now = new Date("2026-02-12T12:00:00Z");
		fs.mkdirSync(archiveDir, { recursive: true });

		// Write an old archived config and set its mtime to 100 days ago
		const oldFile = path.join(archiveDir, "ancient-event.json");
		writeJson(oldFile, { name: "Ancient Event" });
		const oldDate = new Date(now.getTime() - 100 * 86400000);
		fs.utimesSync(oldFile, oldDate, oldDate);

		// Write a recent archived config
		const recentFile = path.join(archiveDir, "recent-event.json");
		writeJson(recentFile, { name: "Recent Event" });

		const result = syncConfigs({ configDir, archiveDir, now });
		expect(result.archiveCleaned).toBe(1);
		expect(fs.existsSync(oldFile)).toBe(false);
		expect(fs.existsSync(recentFile)).toBe(true);
	});
});

// --- cleanupArchive ---

describe("cleanupArchive()", () => {
	it("returns 0 when archive directory does not exist", () => {
		const removed = cleanupArchive("/nonexistent/archive");
		expect(removed).toBe(0);
	});

	it("deletes files older than 90 days", () => {
		const now = new Date("2026-02-12T12:00:00Z");
		fs.mkdirSync(archiveDir, { recursive: true });

		const oldFile = path.join(archiveDir, "old.json");
		writeJson(oldFile, { name: "Old" });
		const oldDate = new Date(now.getTime() - 91 * 86400000);
		fs.utimesSync(oldFile, oldDate, oldDate);

		const freshFile = path.join(archiveDir, "fresh.json");
		writeJson(freshFile, { name: "Fresh" });

		const removed = cleanupArchive(archiveDir, now);
		expect(removed).toBe(1);
		expect(fs.existsSync(oldFile)).toBe(false);
		expect(fs.existsSync(freshFile)).toBe(true);
	});
});
