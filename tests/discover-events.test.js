import { describe, it, expect, beforeEach, afterEach } from "vitest";
import fs from "fs";
import path from "path";
import os from "os";
import {
	findResearchTasks,
	buildResearchPrompt,
	parseDiscoveryResult,
	applyDiscovery,
} from "../scripts/discover-events.js";

let tmpDir;

function writeJson(filePath, data) {
	fs.mkdirSync(path.dirname(filePath), { recursive: true });
	fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
}

beforeEach(() => {
	tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), "discover-events-test-"));
});

afterEach(() => {
	fs.rmSync(tmpDir, { recursive: true, force: true });
});

// --- findResearchTasks ---

describe("findResearchTasks()", () => {
	it("finds configs with needsResearch flag", () => {
		const configs = [
			{
				filename: "skeleton.json",
				config: { name: "Skeleton", needsResearch: true, autoGenerated: true, events: [] },
			},
		];
		const tasks = findResearchTasks(configs, null);
		expect(tasks).toHaveLength(1);
		expect(tasks[0].type).toBe("new-config");
		expect(tasks[0].priority).toBe(1);
	});

	it("finds autoGenerated configs with empty events", () => {
		const configs = [
			{
				filename: "auto.json",
				config: { name: "Auto", autoGenerated: true, events: [] },
			},
		];
		const tasks = findResearchTasks(configs, null);
		expect(tasks).toHaveLength(1);
		expect(tasks[0].type).toBe("new-config");
		expect(tasks[0].priority).toBe(2);
	});

	it("finds configs with stale norwegianAthletes", () => {
		const now = new Date("2026-02-12T12:00:00Z");
		const configs = [
			{
				filename: "olympics.json",
				config: {
					name: "Olympics",
					norwegianAthletes: ["Klaebo"],
					lastResearched: "2026-02-01T00:00:00Z", // 11 days ago
					events: [{ title: "Event", time: "2026-02-20T10:00:00Z" }],
				},
			},
		];
		const tasks = findResearchTasks(configs, null, now);
		expect(tasks).toHaveLength(1);
		expect(tasks[0].type).toBe("refresh-athletes");
		expect(tasks[0].priority).toBe(3);
	});

	it("skips configs with recently refreshed athletes", () => {
		const now = new Date("2026-02-12T12:00:00Z");
		const configs = [
			{
				filename: "fresh.json",
				config: {
					name: "Fresh",
					norwegianAthletes: ["Klaebo"],
					lastResearched: "2026-02-10T00:00:00Z", // 2 days ago
					events: [{ title: "Event", time: "2026-02-20T10:00:00Z" }],
				},
			},
		];
		const tasks = findResearchTasks(configs, null, now);
		expect(tasks).toHaveLength(0);
	});

	it("finds actionable coverage gaps", () => {
		const configs = [];
		const gaps = {
			gaps: [
				{
					id: "champions-league",
					sport: "football",
					type: "tournament",
					matchedPattern: "champions league",
					confidence: "high",
					classification: "actionable",
					suggestedConfigName: "football-champions-league-2026.json",
				},
			],
		};
		const tasks = findResearchTasks(configs, gaps);
		expect(tasks).toHaveLength(1);
		expect(tasks[0].type).toBe("coverage-gap");
		expect(tasks[0].priority).toBe(4);
	});

	it("skips low confidence gaps", () => {
		const gaps = {
			gaps: [
				{
					id: "minor-event",
					sport: "tennis",
					type: "tournament",
					matchedPattern: "minor",
					confidence: "low",
					classification: "actionable",
				},
			],
		};
		const tasks = findResearchTasks([], gaps);
		expect(tasks).toHaveLength(0);
	});

	it("limits tasks to MAX_TASKS_PER_RUN (3)", () => {
		const configs = [
			{ filename: "a.json", config: { name: "A", needsResearch: true, autoGenerated: true, events: [] } },
			{ filename: "b.json", config: { name: "B", needsResearch: true, autoGenerated: true, events: [] } },
			{ filename: "c.json", config: { name: "C", needsResearch: true, autoGenerated: true, events: [] } },
			{ filename: "d.json", config: { name: "D", needsResearch: true, autoGenerated: true, events: [] } },
		];
		const tasks = findResearchTasks(configs, null);
		expect(tasks).toHaveLength(3);
	});

	it("prioritizes needsResearch over empty events over stale athletes", () => {
		const now = new Date("2026-02-12T12:00:00Z");
		const configs = [
			{
				filename: "stale.json",
				config: {
					name: "Stale",
					norwegianAthletes: ["X"],
					lastResearched: "2026-01-01T00:00:00Z",
					events: [{ title: "E", time: "2026-02-20T10:00:00Z" }],
				},
			},
			{
				filename: "empty.json",
				config: { name: "Empty", autoGenerated: true, events: [] },
			},
			{
				filename: "flagged.json",
				config: { name: "Flagged", needsResearch: true, autoGenerated: true, events: [] },
			},
		];
		const tasks = findResearchTasks(configs, null, now);
		expect(tasks[0].priority).toBe(1); // needsResearch
		expect(tasks[1].priority).toBe(2); // empty events
		expect(tasks[2].priority).toBe(3); // stale athletes
	});
});

// --- buildResearchPrompt ---

describe("buildResearchPrompt()", () => {
	it("builds prompt for new-config task", () => {
		const task = {
			type: "new-config",
			config: { name: "Champions League 2026", sport: "football", events: [] },
		};
		const prompt = buildResearchPrompt(task, { favoriteTeams: ["Barcelona"] });
		expect(prompt).toContain("Champions League 2026");
		expect(prompt).toContain("football");
		expect(prompt).toContain("Barcelona");
		expect(prompt).toContain("ISO 8601");
	});

	it("builds prompt for refresh-athletes task", () => {
		const task = {
			type: "refresh-athletes",
			config: {
				name: "Olympics 2026",
				sport: "olympics",
				norwegianAthletes: ["Klaebo", "Johaug"],
			},
		};
		const prompt = buildResearchPrompt(task, null);
		expect(prompt).toContain("Refresh Norwegian athletes");
		expect(prompt).toContain("Klaebo");
		expect(prompt).toContain("Johaug");
		expect(prompt).toContain("retirements");
	});

	it("builds prompt for coverage-gap task", () => {
		const task = {
			type: "coverage-gap",
			gap: { sport: "tennis", matchedPattern: "french open" },
		};
		const prompt = buildResearchPrompt(task, null);
		expect(prompt).toContain("french open");
		expect(prompt).toContain("tennis");
	});
});

// --- parseDiscoveryResult ---

describe("parseDiscoveryResult()", () => {
	it("parses valid JSON", () => {
		const raw = JSON.stringify({
			events: [{ title: "Match", time: "2026-06-15T21:00:00+02:00" }],
			norwegianAthletes: ["Viktor Hovland"],
			location: "Paris",
			startDate: "2026-06-10",
			endDate: "2026-06-20",
		});
		const result = parseDiscoveryResult(raw);
		expect(result.events).toHaveLength(1);
		expect(result.norwegianAthletes).toContain("Viktor Hovland");
	});

	it("extracts JSON from markdown fences", () => {
		const raw = "Here's the data:\n```json\n{\"events\": [{\"title\": \"Match\", \"time\": \"2026-06-15T21:00:00Z\"}]}\n```";
		const result = parseDiscoveryResult(raw);
		expect(result.events).toHaveLength(1);
	});

	it("throws on invalid JSON", () => {
		expect(() => parseDiscoveryResult("not json")).toThrow("Could not parse JSON");
	});

	it("throws when events is not an array", () => {
		const raw = JSON.stringify({ events: "not an array" });
		expect(() => parseDiscoveryResult(raw)).toThrow("events must be an array");
	});

	it("throws when event is missing title", () => {
		const raw = JSON.stringify({ events: [{ time: "2026-06-15T21:00:00Z" }] });
		expect(() => parseDiscoveryResult(raw)).toThrow("title");
	});

	it("throws when event has invalid time", () => {
		const raw = JSON.stringify({ events: [{ title: "X", time: "not-a-date" }] });
		expect(() => parseDiscoveryResult(raw)).toThrow("Invalid time");
	});

	it("throws when norwegianAthletes is not an array", () => {
		const raw = JSON.stringify({ norwegianAthletes: "not an array" });
		expect(() => parseDiscoveryResult(raw)).toThrow("norwegianAthletes must be an array");
	});

	it("accepts result with only norwegianAthletes (athlete refresh)", () => {
		const raw = JSON.stringify({
			norwegianAthletes: ["Klaebo", "Johaug"],
			changes: ["Added Klaebo"],
		});
		const result = parseDiscoveryResult(raw);
		expect(result.norwegianAthletes).toHaveLength(2);
		expect(result.changes).toHaveLength(1);
	});
});

// --- applyDiscovery ---

describe("applyDiscovery()", () => {
	it("merges events and metadata into config", () => {
		const now = new Date("2026-02-12T12:00:00Z");
		const config = {
			name: "Test Event",
			sport: "football",
			autoGenerated: true,
			needsResearch: true,
			events: [],
			location: "TBD",
		};
		const result = {
			events: [{ title: "Match", time: "2026-06-15T21:00:00+02:00" }],
			norwegianAthletes: ["Martin Odegaard"],
			location: "Paris, France",
			startDate: "2026-06-10",
			endDate: "2026-06-20",
		};

		const updated = applyDiscovery(config, result, now);
		expect(updated.events).toHaveLength(1);
		expect(updated.norwegianAthletes).toContain("Martin Odegaard");
		expect(updated.location).toBe("Paris, France");
		expect(updated.startDate).toBe("2026-06-10");
		expect(updated.endDate).toBe("2026-06-20");
		expect(updated.needsResearch).toBe(false);
		expect(updated.autoGenerated).toBe(true);
		expect(updated.lastResearched).toMatch(/2026-02-12/);
	});

	it("preserves autoGenerated flag", () => {
		const config = { name: "Test", autoGenerated: true, events: [] };
		const result = { events: [{ title: "E", time: "2026-06-15T21:00:00Z" }] };
		const updated = applyDiscovery(config, result);
		expect(updated.autoGenerated).toBe(true);
	});

	it("does not overwrite location with TBD", () => {
		const config = { name: "Test", location: "London", events: [] };
		const result = { events: [], location: "TBD" };
		const updated = applyDiscovery(config, result);
		expect(updated.location).toBe("London");
	});

	it("keeps existing events when result has empty events", () => {
		const config = { name: "Test", events: [{ title: "Existing" }] };
		const result = { events: [] };
		const updated = applyDiscovery(config, result);
		expect(updated.events).toHaveLength(1);
		expect(updated.events[0].title).toBe("Existing");
	});

	it("clears needsResearch when events are found", () => {
		const config = { name: "Test", needsResearch: true, events: [] };
		const result = { events: [{ title: "New", time: "2026-06-15T21:00:00Z" }] };
		const updated = applyDiscovery(config, result);
		expect(updated.needsResearch).toBe(false);
	});
});
